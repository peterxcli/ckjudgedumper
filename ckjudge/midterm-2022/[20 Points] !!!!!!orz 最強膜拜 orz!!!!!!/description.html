<h2>[20 Points] !!!!!!orz 最強膜拜 orz!!!!!!</h2>
<h3>Description</h3>
<div>
<p>某天 V 導遊路過電資星，遇到電資星的上的長老他說：「電資星存在著一種特殊的能源，這種能源叫<strong>膜拜量</strong>，且一群電資星人在進行膜拜的時候都會隔一段距離排成一列並擺出以下姿勢 <strong>orz</strong>，會根據每兩個連續的電資星人之間雜質種類乘以雜質數量產生膜拜量。」</p><p></p><p>經過 V 導遊的觀察，空間的雜質可以轉換為小寫英文單字，並且打算為電資星撰寫一個分析程式，能夠在一群電資星人膜拜的時候，找出哪一段的膜拜量最大，以及膜拜量最大的那段靠左與靠右的電資星人的位置，若最大膜拜量存在兩組人能夠產生，請輸出最先出現的（以頭的位置代表自身位置，也就是 orz 中 o 的位置）。但 V 導遊不會寫程式，因此想要你撰寫一個程式為電資星出一份力。</p><p></p><p><strong>測資確保一定會有兩位電資星人，換句話說，一定會有答案。</strong></p><p><strong>注意 orz 才是電資星人，ooooorrrrrzzz 或 ooooorrz 都不是。</strong></p><p></p><p>請實作以下函式：</p><ol><li><p><code>find_orz()</code>：尋找各個電資星人的位置，紀錄於 <code>orz_position</code>（各個電資星人的位置陣列）當中，並更新 <code>orz_num</code>（有幾位電資星人）。</p></li><li><p><code>calculate_worship()</code>：計算各兩相鄰的電資星人之間所產生的膜拜量，並紀錄於 <code>worship_amount</code>（各兩個電資星人產生的的膜拜量陣列）當中。</p></li><li><p><code>find_max_worship_range()</code>：尋找產生最大的膜拜量的區間，並更新 <code>max_worship</code>（最大的膜拜量）、<code>range_L</code>（最先發生最大膜拜量的區間，其靠左電資星人的位置）、<code>range_R</code>（最先發生最大膜拜量的區間，其靠右電資星人的位置）。若有兩個以上的區間產生了最大膜拜量，則以最先出現的為主。</p></li></ol><p></p><p>Ex.</p><p><code>oworzabcdorzzzwooorzw</code></p><p>以上包含三位電資星人，分別在位置 3、10、18，代表會有兩段能產生膜拜量，分別是 3、10 以及 10、18。</p><ul><li><p>3、10 之間雜質種類為 4 種，雜質數量為 4，因此膜拜量為 16。</p></li><li><p>10、18 之間的雜質種類為 3 種，雜質數量為 5，因此膜拜量為 15。</p></li></ul><p>因此，3、10 會產生最大膜拜量，輸出 <code>16 3 10</code></p><p><strong>注意：3、18 不是連續的電資星人，中間包含了 10，因此不會產生膜拜量。</strong></p><p></p><hr><p></p><p>One day V guide passed by the planet Denshi and met the elder of Denshi who said, "There is a special energy source on Denshi, this energy source is called the amount of worship, and a group of Denshi people in worship will be lined up at some distance and the following gesture orz, will be based on the type of impurity between every two consecutive Denshi multiplied by the amount of impurity to generate worship.</p><p></p><p>After the observation of V-Guide, the spatial impurities can be converted into lowercase English words, and we plan to write an analysis program for the Dentsu to find out which section has the largest amount of worship when a group of Dentsu worship, and the position of the Dentsu to the left and right of the section with the largest amount of worship, if the largest amount of worship can be generated by two groups of people, please output the first one (the position of the head represents its own position) If there are two groups of maximum worshipers, please output the first one (the position of the head represents its own position, which is the position of o in orz). However, V-Guide does not know how to write programs, so we want you to write a program to contribute to Denshi.</p><p></p><p><strong>The test ensures that there will definitely be two telemetry stars, in other words, there will definitely be an answer.</strong></p><p><strong>Note that orz is the electric capitalist, oooooorrrrrrzzz or ooooorrz are not.</strong></p><p></p><p>Please implement the following functions:</p><ol><li><p><code>find_orz()</code>: Find the position of each electric capitalist, record the position in <code>orz_position</code> (the position array of each electric capitalist), and update<code>orz_num</code> (the number of electric capitalists).</p></li><li><p><code>calculate_worship()</code>: Find the amount of worship generated by each of the two adjecent electric capitalists, and record the amount in <code>worship_amount</code> (the array of worship generated by each of the two electric capitalist).</p></li><li><p><code>find_max_worship_range()</code>: Find the range that generates the maximum amount of worship, and update <code>max_worship</code> (the maximum amount of worship), <code>range_L</code> (the position of the left electric capitalist of the first range that generates the maximum amount of worship), and <code>range_R</code> (the position of the right electric capitalist of the first range that generates the maximum amount of worship). If there are more than two range that generate the maximum value, the first one is preferred.</p><p></p></li></ol><p>Ex.</p><p><code>oworzabcdorzzzwooorzw</code></p><p>The above includes three electricians at index 3, 10 and 18, which means that there are two segments that can generate worship volume, 3, 10 and 10, 18 respectively.</p><ul><li><p>The number of types of the impurity  between 3 and 10 is 4, and the impurity quantity is 4, so the amount of worship is 16.</p></li><li><p>The number of types of the impurity between 10 and 18 is 3 and the impurity quantity is 5, so the amount of worship is 15.</p></li></ul><p>Therefore, 3 and 10 generate the maximum amount of worship and output <code>16 10 18</code>.</p><p><strong>Note that 3 and 18 are not consecutive electron stars and contain 10 in between, so they do not generate the worship amount.</strong></p>
</div>
<p></p>
<h3>Input</h3>
第一行有一個正整數 N（1 ≦ N ≦ 10^5），代表序列 S 有幾個字元。

第二行有 N 個字元 S_1、S_2...S_N，代表序列 S 的元素。（對所有 1 ≦ i ≦ N，S_i 皆為小寫英文單字）

The first line has a positive integer N (1 ≦ N ≦ 10^5), representing the sequence S with several literals.

The second line has N characters S_1, S_2.... S_N, representing the elements of the sequence S. (For all 1 ≦ i ≦ N, S_i are lowercase English words)


<p></p>
<h3>Output</h3>
輸出包含三個正整數 M L R，以空白隔開，分別代表最大膜拜量、能產生最大膜拜量的兩位電資星人的位置。
若有多組，請輸出先出現的。

The output contains three positive integers M L R, separated by a blank space, representing the maximum worship volume and the positions of the two electric stars that can generate the maximum worship volume.
If there are multiple groups, please output the one that appears first.
<p></p>
<h3>Loader Code</h3>
<div>
<p>Your code will be judge using this program:</p>
</div>
<pre>
#include <&zwj;stdio.h>
#include <&zwj;stdbool.h>
#define MAX_LEN 200000

int N;
char str[MAX_LEN];

void find_orz(int orz_position[], int *orz_num);
void calculate_worship(int worship_amount[], int range_index, int left_orz_position, int right_orz_position);
int find_max_worship_range(int value, int *range_L, int *range_R, int left_orz_position, int right_orz_position);

int main()
{
    scanf("%d", &N);
    scanf("%s", str);

    int orz_position[MAX_LEN] = {0}, worship_amount[MAX_LEN] = {0}, orz_num = 0;
    find_orz(orz_position, &orz_num);

    for (int i = 1; i <&zwj; orz_num; i++)
    {
        calculate_worship(worship_amount, i - 1, orz_position[i - 1], orz_position[i]);
    }

    int max_worship, range_L, range_R;
    for (int i = 0; i <&zwj; orz_num - 1; i++)
    {
        max_worship = find_max_worship_range(worship_amount[i], &range_L, &range_R, orz_position[i], orz_position[i + 1]);
    }
    printf("%d %d %d\n", max_worship, range_L, range_R);
}

</pre>
<div>
<h3>Sample1</h3>
<h4>Input</h4>
<pre>
21
oworzabcdorzzzwooorzw
</pre>
<h4>Output</h4>
<pre>
16 3 10

</pre>
</div>
<div>
<h3>Sample2</h3>
<h4>Input</h4>
<pre>
30
hcoorzkbjjhkuorzqucooorrrzzznn
</pre>
<h4>Output</h4>
<pre>
35 4 14

</pre>
</div>
